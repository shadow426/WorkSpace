动态编译
静态编译
动态库和静态库是两种常见的程序库，它们在程序的构建、链接和加载方式上有所不同。以下是它们的主要区别：
1. 链接方式

1.静态库（Static Library）：静态库是在编译时被直接链接到程序中的。即在编译阶段，编译器会将库文件中的代码和数据直接嵌入到可执行文件中。生成的可执行文件包含了所有的代码和资源，不再依赖于外部的库文件。
2.动态库（Dynamic Library）：动态库则是在程序运行时加载的，编译时并不将其包含在可执行文件中。可执行文件只包含对动态库的引用，而动态库文件则在运行时由操作系统加载。常见的动态库文件扩展名为 .dll（Windows）或 .so（Linux）。

2. 文件大小

3.静态库：静态库会将所需的库代码复制到最终生成的可执行文件中，因此生成的可执行文件较大。
4.动态库：因为动态库代码是在运行时加载的，最终的可执行文件通常较小。

3. 程序的独立性

5.静态库：程序不依赖于外部库文件，静态库包含了所有必要的代码，因此可以在没有库文件的情况下运行。
6.动态库：程序依赖于动态库文件，必须确保动态库在运行时可用，否则程序将无法启动或运行。

4. 内存使用

7.静态库：每个使用静态库的程序都会复制一份库的代码，多个程序可能会有重复的代码片段，从而导致内存浪费。
8.动态库：多个程序可以共享同一个动态库，减少内存使用。操作系统加载动态库时，将库文件加载到内存中，多个程序可以使用相同的库文件实例。

5. 更新与维护

9.静态库：如果需要修复库中的错误或更新功能，必须重新编译所有依赖该库的程序。每个程序都需要更新。
10.动态库：更新动态库时，程序不需要重新编译，只要更新的库与原有接口兼容，程序即可直接使用新版本的动态库。

6. 加载时机

11.静态库：静态库的链接发生在编译时，程序启动前就已经确定了需要的库。
12.动态库：动态库的加载发生在程序运行时，操作系统会在程序启动或运行时加载这些库。

7. 跨平台

13.静态库：不同平台上，静态库的格式可能不同。不同操作系统和架构下需要编译不同版本的静态库。
14.动态库：动态库通常具有跨平台的特性，操作系统会根据平台加载相应的动态库文件。

8. 调试

15.静态库：因为静态库的代码已经嵌入到可执行文件中，调试时需要调试整个程序，且库的代码不容易更新。
16.动态库：可以在不重新编译程序的情况下更新和调试动态库，方便进行热更新和调试。

总结：

17.静态库：在编译时链接到程序，程序生成后不依赖外部库文件，文件较大，内存使用较低。
18.动态库：在运行时加载到程序，程序依赖外部库文件，文件较小，内存使用较高，可以共享库，更新和维护较为方便。

选择静态库还是动态库通常取决于具体的应用需求，比如性能、内存使用、更新频率等。



同步（Synchronous）和异步（Asynchronous）是计算机科学中描述任务执行方式的两个概念，常用于多任务处理、编程和计算模型中。
1. 同步（Synchronous）
同步是指在执行多个任务时，任务按顺序执行，后一个任务必须等待前一个任务完成后才能开始。换句话说，任务是按照一定的时间顺序逐个执行的。

1.特点:
2.每个任务按顺序执行，直到前一个任务完成，后一个才能开始。
3.当前任务在执行时，会阻塞后续任务，直到当前任务完成。
4.程序的控制流是线性的。
5.应用场景:
6.多数传统编程模型、程序执行时，函数调用、方法执行都依赖同步执行。
7.例如，数据库操作、文件读写等，在这些操作中，一般需要等待数据获取后，才能进行后续处理。
8.例子:
假设你在打印机上打印文件：


9.打印机开始打印任务。
10.在打印机完成当前任务前，你无法执行其他打印任务。

2. 异步（Asynchronous）
异步是指任务不需要等待前一个任务完成，可以同时启动多个任务。即使一个任务正在执行，其他任务也可以并行或在等待过程中执行，而不阻塞其他任务。

11.特点:
12.任务不需要按顺序执行，后续任务可以在前一个任务尚未完成时就开始执行。
13.一旦任务完成，它会通过回调、事件等机制通知调用方，通知可以是无阻塞的。
14.提高了资源的使用效率和程序的响应性。
15.应用场景:
16.网络请求、I/O操作、数据库操作等需要等待的操作。
17.现代Web开发中，前端通常采用异步请求（如AJAX）来避免页面的卡顿，提升用户体验。
18.例子:
假设你要打印一份文件，并且同时做其他事情：


19.打印任务被提交，但你不需要等待它完成。
20.你可以同时浏览网页、发邮件等，打印任务会在后台完成。
21.打印完成后，系统会通知你文件已经打印完毕。

同步与异步的区别
| 特性               | 同步（Synchronous）             | 异步（Asynchronous）             |
|------------------|------------------------------|-------------------------------|
| 执行方式        | 按顺序执行，后一个任务等待前一个完成   | 同时执行，任务并行或独立完成        |
| 阻塞            | 当前任务阻塞后续任务执行            | 不阻塞，后续任务可以立刻执行        |
| 资源利用        | 资源可能被阻塞，等待时间较长         | 提高资源利用率，等待时间较短        |
| 编程复杂度      | 较为简单，执行顺序明确               | 需要回调、事件或未来对象等机制     |
| 应用场景        | 适用于不需要长时间等待的任务，或任务依赖性强的场景 | 适用于需要等待的任务，如I/O操作、网络请求等 |
同步与异步的例子

22.同步：你请求一个网站，浏览器等待网页加载完毕后才能进行其他操作。如果网页加载需要很长时间，浏览器会暂时卡住。
23.异步：你请求一个网站，但不需要等待网页加载完成。你可以继续在其他页面上浏览，直到网页加载完成，浏览器会通过回调或事件来通知你。

总结

24.同步适用于任务需要严格按顺序执行的场景。
25.异步适用于任务之间独立，且等待过程不会影响其他任务执行的场景。

两者的选择取决于任务的性质、性能需求以及对用户体验的要求。


  
#### USB Host是什么意思

USB Host（USB主机）是指计算机或其他设备中用于控制和管理与外部USB设备（如USB闪存驱动器、键盘、鼠标、打印机、摄像头等）之间通信的硬件和软件系统。在USB通信协议中，设备分为两种角色：主机（Host）和从机（Device）。USB主机是负责管理数据传输、控制连接的设备，而USB设备则是连接到主机的外部硬件。
USB Host的主要功能：

1.设备管理：USB主机负责识别连接的外部设备，加载适当的驱动程序，并与设备进行通信。
2.数据传输控制：主机控制数据传输的时序和方式，确保数据从主机传输到设备，或反方向传输。
3.电源管理：在USB协议中，USB主机还负责向连接的USB设备提供电力（通常是通过5V电压），这对于一些小型外设（如USB键盘、鼠标等）来说非常重要。

示例：

4.计算机：电脑的USB接口通常充当USB主机的角色，负责管理所有连接的外部设备，如打印机、摄像头、存储设备等。
5.智能手机：许多智能手机具备USB OTG（On-The-Go）功能，能够在连接USB设备时充当USB主机，从而与外部存储、键盘、鼠标等设备进行交互。

总结：
USB Host是指能够控制和管理与USB设备之间通信的主控设备，在大多数计算机和移动设备中扮演着重要的角色。它负责确保连接的USB设备可以正常工作，并通过数据传输实现设备间的交互。




先来看一看 ARM64 架构，ARM64（也称为 ARMv8-A 或 ARM 64-bit）是一种 64 位的处理器架构，由 ARM Holdings 设计。ARM 处理器架构采用 **RISC**（精简指令集计算）设计，旨在通过减少每条指令的复杂性和功耗来提高计算效率。ARM64 架构通常应用于移动设备、嵌入式系统、智能设备、以及越来越多的服务器和高性能计算机中。



x86 是由 [Intel](https://www.dians.net/thread-5022.htm) 在 1980 年代初期开发的架构，其名称源自最早的 8086 处理器。x86 是基于 **CISC**（复杂指令集计算）设计的一种架构，具有强大的指令集和向后兼容性，广泛应用于台式机、笔记本电脑和服务器。x86 处理器由于其强大的性能和高度兼容性，一直是 PC 领域的主流架构。


x64（也叫 x86-64 或 AMD64）是由 AMD 提出的 64 位扩展版本的 x86 架构。它最早出现在 AMD 的 Opteron 处理器中，并且被 Intel 的处理器所采纳。x64 架构保留了 x86 的兼容性，同时扩展了地址总线的宽度，使其能够支持更大内存和更高的性能。与 x86 不同，x64 架构能够处理更大的数据量，更高效地执行 64 位指令，并支持更大的内存空间。


那这三种架构之间的区别都有哪些呢？下面给大家总结了一些区别：

- **架构设计：**ARM64 基于精简指令集计算架构，x86 基于复杂指令集计算架构，x64 是 x86 架构的 64 位扩展。
    
- **性能和效率：**ARM64 低功耗、适合高效能计算和移动设备，x86 性能强劲，适用于高负载应用，但功耗较高，x64 在性能和效率上都有所提升，适合需要大量内存和并行计算的场景。


[使用 Qt 开发多平台 USB 应用程序 [Mental Workbench]](https://wiki.kucia.net/doku.php?id=projects:qtusb)


![[Pasted image 20250122001105.png]]